<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Mid-end intermediate representation</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  if (toggleSwitch !== null) {
    toggleSwitch.addEventListener('change', switchTheme, false);
  }

  var currentTheme = localStorage.getItem('theme');
  if (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    currentTheme = 'dark';
  }
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark' && toggleSwitch !== null) {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Mid-end intermediate representation</h1>
    <div class="admonition admonition-info"><span class="admonition-info-text"><b>Note:</b></span>
This document is a work in progress.</div>

<h1 id="overview">Overview</h1><p>The MIR is a desugared, simplified, and flattened intermediate representation (=IR) of NimSkull code that is intended for analysis, transformations, and lowerings.</p>
<p>In the compilation pipeline, the stage using the MIR is located after semantic analysis and high-level transformation (<tt class="docutils literal"><span class="pre">transf</span></tt>) but before code generation.</p>
<div class="admonition admonition-info"><span class="admonition-info-text"><b>Note:</b></span>
The plan is to replace the current IR consumed by the code generators (i.e., the <tt class="docutils literal"><span class="pre">CgNode</span></tt> IR) with the MIR</div>

<h1 id="semantics">Semantics</h1><pre class="listing">NAME = &lt;Temp&gt;   # a temporary introduced during the MIR phase
     | &lt;Alias&gt;  # a temporary view introduced during the MIR phase
     | &lt;Local&gt;  # a user-defined local or temporary introduce prior to the
                # MIR phase
     | &lt;Global&gt; # a user-defined global
     | &lt;Const&gt;  # a user-defined constant

LVALUE = NAME
       | PathNamed   LVALUE &lt;Field&gt;    # named field access (objects only)
       | PathPos     LVALUE &lt;Position&gt; # positional field access (tuples only)
       | PathVariant LVALUE &lt;Field&gt;    # access a variant within an object
       | PathConv    LVALUE &lt;Type&gt;     # access a sub- or super-type of
       | PathArray   LVALUE (NAME | &lt;Literal&gt;) # access an array at given
                                       # position
       | Deref       NAME              # dereference a `ptr` or `ref`
       | DerefView   NAME              # dereference a `var` or `lent`

VALUE = &lt;Literal&gt;
      | &lt;ProcVal&gt;
      | &lt;Type&gt;
      | LVALUE

INTERMEDIATE_TARGET = &lt;Label&gt;
                    | Leave &lt;Label&gt;

TARGET = &lt;Label&gt;
       | TargetList INTERMEDIATE_TARGET ... &lt;Label&gt;

EX_TARGET = TARGET
          | TargetList INTERMEDIATE_TARGET ... Resume

UNARY_OP = NegI VALUE

BINARY_OP = AddI VALUE, VALUE
          | SubI VALUE, VALUE
          | MulI VALUE, VALUE
          | DivI VALUE, VALUE
          | ModI VALUE, VALUE

CALL_ARG = Arg VALUE                    # pass-by-value argument
         | Arg &lt;none&gt;                   # argument that's going to be omitted
                                        # later
         | Name &lt;Effect&gt; LVALUE         # pass-by-name argument. The effect
                                        # specifies the effect the call has
                                        # on the value/location
         | Consume VALUE                # pass-by-value argument, but
                                        # the value is consumed (i.e., moved)

CONSTR_ARG = Arg VALUE
           | Consume OPERAND

CALL_EXPR = Call &lt;Imm&gt; &lt;Proc&gt; CALL_ARG ...  # a static call of the provided
                                            # procedure with the given
                                            # arguments
          | Call &lt;Imm&gt; LVALUE CALL_ARG ...  # indirect call
          | Call &lt;Imm&gt; &lt;Magic&gt; CALL_ARG ... # a call of a magic procedure
                                            # (i.e., a procedure that is
                                            # either going to be lowered into
                                            # something else, or one for
                                            # which the behaviour cannot
                                            # be represented in the MIR)

# checked calls have the same shape as normal calls. The difference
# is that the call has an exceptional exit (i.e., it might raise an
# exception)
CHECKED_CALL_EXPR = CheckedCall &lt;Imm&gt; &lt;Proc&gt; CALL_ARG ...  EX_TARGET
                  | CheckedCall &lt;Imm&gt; LVALUE CALL_ARG ...  EX_TARGET
                  | CheckedCall &lt;Imm&gt; &lt;Magic&gt; CALL_ARG ... EX_TARGET

SET_CONSTR_ARG = VALUE
               | Range VALUE VALUE     # range construction

BINDING = Binding &lt;Field&gt; CONSTR_ARG

RVALUE = UNARY_OP
       | BINARY_OP
       | CALL_EXPR
       | CHECKED_CALL_EXPR
       | SetConstr SET_CONSTR_ARG ...
       | ArrayConstr CONSTR_ARG...
       | SeqConstr CONSTR_ARG...
       | TupleConstr CONSTR_ARG...
       | ClosureConstr CONSTR_ARG...
       | ObjConstr BINDING ...         # construct an `object`
       | RefConstr BINDING ...         # construct a `ref object`
       | StdConv  VALUE                # number conversion or conversion
                                       # between cstring and string
       | Conv     VALUE                # same as `StdConv`. Only duplicate
                                       # for legacy code generator reasons
       | Cast     VALUE                # reinterpret the value as a different
                                       # type
       | Addr     LVALUE               # create a pointer from the lvalue
       | View     LVALUE               # create a view (`var`/`lent`) of the
                                       # lvalue
       | MutView  LVALUE
       | ToSlice  VALUE                # create an `openArray` slice of
                                       # the full sequence
       | MutToSlice LVALUE
       | ToSlice  VALUE, VALUE, VALUE  # create an `openArray` slice from the
                                       # first operand, starting at the lower
                                       # bound (second parameter) and ending
                                       # at the upper bound (inclusive, third
                                       # parameter)
       | MutToSlice LVALUE, VALUE, VALUE

ASGN_SRC = RVALUE
         | VALUE
         | Copy VALUE
         | Move LVALUE
         | Sink LVALUE

SHALLOW_SRC = RVALUE
            | VALUE

STATEMENT = Scope                     # starts a new scope, which
                                      # delimits the lifetime of all
                                      # definitions within
          | EndScope                  # close the current scope
          | Def NAME none             # definition
          | Def NAME ASGN_SRC         # definition + initial value assignment
          | DefCursor NAME            # definition of non-owning location
          | DefCursor NAME SHALLOW_SRC# definition of non-owning location +
                                      # initial (shallow copy) assignment
          | Bind &lt;Alias&gt; LVALUE       # bind the lvalue to the given alias.
                                      # May be used for mutation, but must
                                      # not be used as an assignment's
                                      # destination or `Tag`'s operand
          | BindMut &lt;Alias&gt; LVALUE    # bind the lvalue to the given alias.
                                      # The alias may be used as an
                                      # assignment's destination or as a
                                      # `Tag`'s operand
          | Void LVALUE               # evaluates the lvalue for side-effects
                                      # and acts as a usage of the lvalue
                                      # during data-flow analysis
          | Void CALL_EXPR            # represents a void call. The called
                                      # procedure or magic *must* have a
                                      # `void`` return type
          | Asgn LVALUE ASGN_SRC      # normal assignment of the right value
                                      # to the left location
          | Init LVALUE ASGN_SRC      # initial assignment (the destination
                                      # is empty)
          | Switch LVALUE ASGN_SRC    # changes the active branch of a
                                      # variant. Unclear semantics.
          | If VALUE &lt;Label&gt;          # fall through if the value evaluates
                                      # to true, otherwise jump to the if's
                                      # corresponding end
          | Case VALUE BRANCH_LIST    # dispatch to one of the branches based
                                      # on the value, where value must be
                                      # either of integer, float, or string
                                      # type
          | Goto TARGET
          | Loop &lt;Label&gt;              # unconditional jump back to the start
                                      # of a loop
          | Destroy LVALUE
          | Raise LVALUE EX_TARGET
          | Raise &lt;None&gt; EX_TARGET
          | Join &lt;Label&gt;              # join point for non-exceptional
                                      # control-flow (e.g., goto)
          | LoopJoin &lt;Label&gt;          # join point for `Loop`
          | Except &lt;Type&gt; ... EX_TARGET
          | Except &lt;Local&gt; EX_TARGET
          | Except                    # catch-all handler
          | Finally &lt;Label&gt;
          | Continue &lt;Label&gt; (&lt;Label&gt; | Resume) ...
          | End &lt;Label&gt;               # marks the end of an if, repeat, or
                                      # except
          | Emit VALUE ...
          | Asm VALUE ...

BRANCH_LABEL = &lt;Literal&gt;
             | &lt;Const&gt;
             | Range &lt;Literal&gt; &lt;Literal&gt;
BRANCH_LIST = (Branch BRANCH_LABEL ... TARGET) ... # a list of branches</pre><p>Only allowing calls, conversions, casts, etc. as the source operand (i.e., on the right) of an assignment makes sure that they always have named receivers, which:</p>
<ul class="simple"><li>ensures an atomic statement (e.g., assignment) only has at most one control- flow effect, making control-/data-flow analysis easier</li>
<li>allows for local, assignment-based lowering of call, magics, etc.</li>
</ul>
<p>If a call raises an exception, whether the assignment destination is written to is currently undefined.</p>

<h2 id="types">Types</h2><p><tt class="docutils literal"><span class="pre">PType</span></tt> is currently re-used for representing types at the MIR stage. In the future, the usage of <tt class="docutils literal"><span class="pre">PType</span></tt> will be replaced with simplified and more data- oriented version that betters supports lowering and traversal.</p>

<h2 id="effects">Effects</h2><p>Lvalues passed to by-name parameters may optionally be tagged with an <em>effect</em>. The effect describes what may happen to the underlying location <em>during</em> execution of the procedure. If no effects are specified, the location may only be read from during execution of the procedure.</p>
<p>This information is intended for use by data-flow analysis and code generators.</p>

<h1 id="control-flow-representation">Control Flow Representation</h1><p>Terminology:</p>
<ul class="simple"><li><em>basic block</em>: a basic block is a region of statements that contains no jumps and is not jumped into</li>
<li><em>label</em>: identifies a control-flow-related construct</li>
<li><em>terminator</em>: marks the end of a basic block</li>
</ul>
<p>A basic block is started by <tt class="docutils literal"><span class="pre">Finally</span></tt> and <tt class="docutils literal"><span class="pre">Except</span></tt>. Terminators are: <tt class="docutils literal"><span class="pre">Case</span></tt>, <tt class="docutils literal"><span class="pre">Goto</span></tt>, <tt class="docutils literal"><span class="pre">Raise</span></tt>, <tt class="docutils literal"><span class="pre">Continue</span></tt>, and <tt class="docutils literal"><span class="pre">Loop</span></tt>. <tt class="docutils literal"><span class="pre">If</span></tt>, <tt class="docutils literal"><span class="pre">Join</span></tt>, and <tt class="docutils literal"><span class="pre">LoopJoin</span></tt> act as both the start and end of a basic block. The nature of <tt class="docutils literal"><span class="pre">End</span></tt> depends on the associated construct:</p>
<ul class="simple"><li>for <tt class="docutils literal"><span class="pre">If</span></tt>, it acts as both a terminator and start of a basic block</li>
<li>for <tt class="docutils literal"><span class="pre">Except</span></tt>, it only marks the end of the section</li>
</ul>
<p>Except for <tt class="docutils literal"><span class="pre">Loop</span></tt>, all terminators only allow forward control-flow.</p>

<h2 id="structured-constructs">Structured Constructs</h2><p>Each <tt class="docutils literal"><span class="pre">If</span></tt> and <tt class="docutils literal"><span class="pre">Except</span></tt> must be paired with exactly one <tt class="docutils literal"><span class="pre">End</span></tt>, each <tt class="docutils literal"><span class="pre">LoopJoin</span></tt> with a <tt class="docutils literal"><span class="pre">Loop</span></tt>, and each <tt class="docutils literal"><span class="pre">Finally</span></tt> with a <tt class="docutils literal"><span class="pre">Continue</span></tt>. These are the <em>structured</em> constructs, and they must not overlap each other, meaning that:</p>
<pre class="listing"><span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Punctuation">(</span><span class="Identifier">L1</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">y</span> <span class="Punctuation">(</span><span class="Identifier">L2</span><span class="Punctuation">)</span>
<span class="Keyword">end</span> <span class="Identifier">L1</span>
<span class="Keyword">end</span> <span class="Identifier">L2</span></pre><p>is not allowed. However, much like in the high-level language, structured constructs can be nested.</p>

<h2 id="target-lists">Target Lists</h2><p><tt class="docutils literal"><span class="pre">Goto</span></tt>, <tt class="docutils literal"><span class="pre">Raise</span></tt>, <tt class="docutils literal"><span class="pre">Except</span></tt>, and <tt class="docutils literal"><span class="pre">CheckedCall</span></tt> support <em>target lists</em>. The target list specifies intermediate jump targets as well as which sections are exited. Take, for example:</p>
<pre class="listing"><span class="Identifier">goto</span> <span class="Punctuation">[</span><span class="Identifier">Leave</span> <span class="Identifier">L1</span><span class="Punctuation">,</span> <span class="Identifier">L2</span><span class="Punctuation">,</span> <span class="Identifier">Leave</span> <span class="Identifier">L3</span><span class="Punctuation">,</span> <span class="Identifier">L4</span><span class="Punctuation">]</span></pre><p>What this means is the following:</p>
<ol class="simple"><li>leave the section (<tt class="docutils literal"><span class="pre">Except</span></tt> or <tt class="docutils literal"><span class="pre">Finally</span></tt>) identified by label L1</li>
<li>enter the <tt class="docutils literal"><span class="pre">Finally</span></tt> section identified by label L2</li>
<li>leave the section identified by label L3</li>
<li>land at the <tt class="docutils literal"><span class="pre">Finally</span></tt> or <tt class="docutils literal"><span class="pre">Join</span></tt> identified by label L4</li>
</ol>
<p>An example of the code that would result in such <tt class="docutils literal"><span class="pre">Goto</span></tt>:</p>
<pre class="listing"><span class="Keyword">block</span> <span class="Identifier">L4</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Keyword">try</span>
        <span class="Operator">...</span>
      <span class="Keyword">finally</span><span class="Punctuation">:</span>
        <span class="Keyword">break</span> <span class="Identifier">L4</span> <span class="Comment"># this would translate to the aforementioned goto</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Operator">...</span></pre><p>In the context of exceptional control-flow, the final target must be either a <tt class="docutils literal"><span class="pre">Finally</span></tt> or an <tt class="docutils literal"><span class="pre">Except</span></tt>, otherwise it must be either a <tt class="docutils literal"><span class="pre">Finally</span></tt> or <tt class="docutils literal"><span class="pre">Join</span></tt>.</p>

<h2 id="resume">Resume</h2><p><tt class="docutils literal"><span class="pre">Resume</span></tt> is a special jump target that may only appear as the final target of <tt class="docutils literal"><span class="pre">Raise</span></tt>, <tt class="docutils literal"><span class="pre">CheckedCall</span></tt>, and <tt class="docutils literal"><span class="pre">Except</span></tt>. It specifies that unwinding/exception- handling <em>resumes</em> in the caller procedure.</p>

<h2 id="exception-handler">Exception Handler</h2><p><tt class="docutils literal"><span class="pre">Except</span></tt> represents an exception handler. If types or a local is specified, the section is only entered if the run-time type of the active exception matches the section's filters. If there's a match, execution continues with the statement following the <tt class="docutils literal"><span class="pre">Except</span></tt>, otherwise it continues at the target specified by the <tt class="docutils literal"><span class="pre">Except</span></tt>.</p>

<h2 id="finally-sections">Finally Sections</h2><p>A <tt class="docutils literal"><span class="pre">Finally</span></tt> section is used as an intermediate target in a jump chain. Where the <tt class="docutils literal"><span class="pre">Continue</span></tt> statement marking the end of the section jumps to depends on the <em>target list</em> the entered <tt class="docutils literal"><span class="pre">Finally</span></tt> is part of. For example, with <tt class="docutils literal"><span class="pre">Goto [L1, L2]</span></tt>, the <tt class="docutils literal"><span class="pre">Continue</span></tt> of the <tt class="docutils literal"><span class="pre">Finally</span></tt> section identified by L1 would jump to L2.</p>
<p>The <tt class="docutils literal"><span class="pre">Continue</span></tt> must also be present if it is never actually reached. In this case, the <tt class="docutils literal"><span class="pre">Finally</span></tt> section may only appear as the final target in a target list.</p>

<h1 id="storage">Storage</h1><p>The MIR uses a tree-based representation similar to the AST. For easier processing and faster access, the whole code for a procedure is stored in a single sequence of <em>nodes</em>, with the nodes forming a tree.</p>

<h1 id="constant-expressions">Constant Expressions</h1><p>MIR constant expression are stored separately from MIR trees representing routine bodies. Constant expressions describe a value not depending on any dynamic/run-time information. They use a variation/sub-set of the MIR that is better suited for statement-less trees.</p>
<p>The syntax is similar to that of the normal MIR, with the biggest difference being that the representation is flat (i.e., a single tree rather than multiple ones).</p>
<pre class="listing">VALUE = &lt;ProcVal&gt;
      | &lt;Literal&gt;
      | COMPLEX

ARG = Arg VALUE

SET_CONSTR_ARG = &lt;Literal&gt;
               | Range &lt;Literal&gt; &lt;Literal&gt;

BINDING = Binding &lt;Field&gt; ARG

COMPLEX = SetConstr SET_CONSTR_ARG...
        | ArrayConstr ARG...
        | SeqConstr ARG...
        | TupleConstr ARG...
        | ClosureConstr ARG...
        | ObjConstr BINDING...
        | RefConstr BINDING...</pre>


    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2024-06-29 00:00:00 UTC</small>
      </div>
    </div>
  </div>
</div>
</body>
</html>
